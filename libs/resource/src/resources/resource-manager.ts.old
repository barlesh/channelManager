import * as uid from "uuid";
import { resourceID } from "../types/types";
import {
  protoActionRequest,
  protoActionResponse,
  protocolActions
} from "./../../../protocol/src/actions";
import { IConnectionManager } from "../../../connections-manager/src/connections";
import { connectionID } from "../../../connections-manager/src/models";

export interface IResourceManager {
  _protocolResponse: protoActionResponse[];
  _protocolRequest: Map<string, protoActionRequest>;
  add(data, id?): resourceID;
  get(id): any;
  size(): number;
  // attachResourceToAgent(agent: Agent, resourceID: resourceID);
  // detachResourceFromAgent(agent: Agent, resourceID: resourceID);
  publishEvent(resourceID: resourceID, event: string, data);
  // detachAgent(agent: Agent);
}

export class ResourceManager implements IResourceManager {
  resourcesList: Map<resourceID, any>;
  _resourceConnectionMap: Map<resourceID, connectionID>;
  _protocolResponse: protoActionResponse[];
  _protocolRequest: Map<string, protoActionRequest>;
  // _connectionManager: IConnectionManager;
  

  constructor(
    responses: protoActionResponse[],
    requests: protoActionRequest[]
  ) {
    if (protocolActions.validateProtocolActionResponse(responses)) {
      this._protocolResponse = responses;
    } else {
      throw new Error("response protocol of bad type");
    }
    this._protocolRequest = new Map();
    if (protocolActions.validateProtocolActionRequest(requests)) {
      this.loadRequestsToMap(requests);
    } else {
      throw new Error("request protocol of bad type");
    }
    this.resourcesList = new Map();
    this._resourceConnectionMap = new Map();
  }

  loadRequestsToMap(actionRequests: protoActionRequest[]) {
    actionRequests.forEach(action => {
      this._protocolRequest.set(action.event, action);
    });
  }

  add(resource, id?): resourceID {
    // validate resource - TODO
    if (!id) {
      id = uid();
    }
    if (this.resourcesList.get(id)) {
      console.warn("resource with the same id exist. abort");
      throw new Error("resource id already exist");
    }
    this.resourcesList.set(id, resource);
    return id;
  }

  get(id: resourceID) {
    return this.resourcesList.get(id);
  }

  size(): number {
    return this.resourcesList.size;
  }

  remove(id: resourceID) {
    this.resourcesList.delete(id);
  }

  getResourcesList() {
    return this.resourcesList;
  }

  // attachResourceToAgent(agent: Agent, resourceID: resourceID) {
  //   if (!this.resourcesList.get(resourceID)) {
  //     throw new Error("resource not exist.");
  //   }

  //   if (!agent) {
  //     console.error("no agent supplied");
  //     throw new Error("no agent supplied");
  //   }
  //   const agentID = agent.getID();
  //   if (!agentID) {
  //     console.error("no agent id supplied in object: ", agent);
  //     throw new Error("no agent id supplied in agent object");
  //   }
  //   console.info(
  //     `attaching agent with agentID: ${agentID} to resource with resourceID: ${resourceID}`
  //   );
  //   this.resourceAgentMap.set(resourceID, agent);

  //   // register resource protocol events TODO
  //   this.registerProtocolEvents(agent);
  //   return true;
  // }

  // detachAgent(agent: Agent) {
  //   const agentID = agent.getID();
  //   console.info(`detaching agent with agentID: ${agentID} from all resources`);
  //   const resourcesToDetach = this.getResourcesByAgent(agentID);
  //   resourcesToDetach.forEach(rid => {
  //     this.resourceAgentMap.delete(rid);
  //   });
  //   console.info(`Detached ${resourcesToDetach.length} resources.`);
  // }

  // detachResourceFromAgent(agent: Agent, resourceID: resourceID) {
  //   const agentID = agent.getID();
  //   console.info(
  //     `detaching agent with agentID: ${agentID} to resource with resourceID: ${resourceID}`
  //   );
  //   this.resourceAgentMap.delete(resourceID);

  //   this.unregisterProtocolEvents(agent);
  // }

  registerProtocolEvents(connectionID: connectionID) {
    try {
      this._protocolResponse.forEach(protocolAction => {
        this._connectionManager.subscribeToConnectionEvent(
          connectionID,
          protocolAction
        );
      });
    } catch (err) {
      console.warn("could not load protocol. error: ", err);
      return;
    }
  }

  unregisterProtocolEvents(connectionID: connectionID) {
    try {
      this._protocolResponse.forEach(protocolElement => {
        this._connectionManager.unsubscribeToConnectionEvent(
          connectionID,
          protocolElement
        );
      });
    } catch (err) {
      console.warn("could not load protocol. error: ", err);
      return;
    }
  }

  //  getResourcesByAgent(agentID: agentID) {
  //    const resourcesToDetach = [];
  //    this.resourceAgentMap.forEach((value, key, map) => {
  //      if (value._id === agentID) {
  //        resourcesToDetach.push(key);
  //      }
  //    });
  //    return resourcesToDetach;
  //  }

  publishEvent(resourceID: resourceID, event: string, data) {
    //  const agent = this.resourceAgentMap.get(resourceID);
    //  if (!agent) {
    //    console.warn(
    //      `could not find agent that hold resource with resource id: ${resourceID}`
    //    );
    //    throw new Error("can not publish event. agent not found");
    //  }
    const cid = this._resourceConnectionMap.get(resourceID);
    const action = this._protocolRequest.get(event);
    this._connectionManager.publishConnectionEvent(cid, action, data);
  }

  myResourceHandler() {}
}
